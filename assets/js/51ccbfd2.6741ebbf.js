"use strict";(self.webpackChunktreeppl_github_io=self.webpackChunktreeppl_github_io||[]).push([[856],{3905:function(t,e,n){n.d(e,{Zo:function(){return m},kt:function(){return k}});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var p=a.createContext({}),d=function(t){var e=a.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},m=function(t){var e=d(t.components);return a.createElement(p.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},s=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),s=d(n),k=r,c=s["".concat(p,".").concat(k)]||s[k]||u[k]||l;return n?a.createElement(c,i(i({ref:e},m),{},{components:n})):a.createElement(c,i({ref:e},m))}));function k(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=s;var o={};for(var p in e)hasOwnProperty.call(e,p)&&(o[p]=e[p]);o.originalType=t,o.mdxType="string"==typeof t?t:r,i[1]=o;for(var d=2;d<l;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}s.displayName="MDXCreateElement"},3133:function(t,e,n){n.r(e),n.d(e,{contentTitle:function(){return p},default:function(){return s},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return m}});var a=n(7462),r=n(3366),l=(n(7294),n(3905)),i=["components"],o={id:"user"},p="TreePPL Cheat Sheet",d={unversionedId:"user",id:"user",title:"TreePPL Cheat Sheet",description:"Basic features",source:"@site/docs/1-user.md",sourceDirName:".",slug:"/user",permalink:"/docs/user",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"user"},sidebar:"tutorialSidebar",previous:{title:"About TreePPL",permalink:"/docs/about"},next:{title:"Phylogenetic Models",permalink:"/docs/phylo"}},m=[{value:"Basic features",id:"basic-features",children:[],level:2},{value:"Working with data",id:"working-with-data",children:[],level:2},{value:"Functions",id:"functions",children:[],level:2},{value:"Probabilistic programming",id:"probabilistic-programming",children:[],level:2},{value:"Examples",id:"examples",children:[{value:"Hello world",id:"hello-world",children:[],level:3},{value:"Blub",id:"blub",children:[],level:3},{value:"Is a coin fair?",id:"is-a-coin-fair",children:[],level:3}],level:2}],u={toc:m};function s(t){var e=t.components,n=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"treeppl-cheat-sheet"},"TreePPL Cheat Sheet"),(0,l.kt)("h2",{id:"basic-features"},"Basic features"),(0,l.kt)("p",null,"Example is ",(0,l.kt)("a",{parentName:"p",href:"#hello-world"},"Hello world"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Implementation"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Single-line comment"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// This is a single line comment"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Multi-line or intervening comment"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"/* This is a multiline/intervening"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"   comment */"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Terminate statements with semi-colon ",(0,l.kt)("inlineCode",{parentName:"td"},";")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'printLn("Hello, world");'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Every program needs to have a model function"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"model function hello() { /* put your code here */ }"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Compiling TreePPL code to binary"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"tpplc hello.tppl input.mc output.mc && mi compile output.mc"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Running compiled programs"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"./output [number of particles] [number of sweeps]"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"[number of samples] [number of chains]")," in the case of MCMC")))),(0,l.kt)("h2",{id:"working-with-data"},"Working with data"),(0,l.kt)("p",null,"Example is ",(0,l.kt)("a",{parentName:"p",href:"#blub"},"Blub"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Implementation"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Data is passed by specifying arguments to the model function"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"model function blub(n: Int, pi: Real, trump: Bool, coinflips: Bool[], text: String)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},"The basic datatypes are integer, real, boolean, and string.  Each of them can be converted to a vector by ",(0,l.kt)("inlineCode",{parentName:"td"},"[]"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Priting and adding a new line"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"printLn(text);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Printing without adding a new line"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"print(text);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Print only an empty line"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'print("\\n"); // printLn() not allowed'))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"All types must be converted to string before printing"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"int2string(n)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"real2string(pi)")," will only take a few decimals")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"bool2string(true)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Concatenating two strings"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},'concat("Trump was elected: ", bool2string(trump)')," Outputs ",(0,l.kt)("inlineCode",{parentName:"td"},"False"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Creating a new vector"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"let testVec = [1, 2]; // will create an integer vector"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Getting the i-th element of the vector"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"testVec[1]")," vectors are 1-indexed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"It is not possible to change individual elements"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"let testVec[1] = x; // compiler error!"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Getting the length of a vector"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"length(coinflips)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Applying a function to each element of a vector"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"let coinFlipStr = apply(bool2string, coinflips);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Joining a vector of strings into a single string"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"join(coinFlipStr)"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Arithmetic operations on reals"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"2.0 + 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 * 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 / 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 - 3.0"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Boolean operations on reals"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"2.0 < 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 <= 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 == 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 >= 3.0"),", ",(0,l.kt)("inlineCode",{parentName:"td"},"2.0 > 3.0"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Boolean operations on booleans"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"true && false")," logical AND")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"true")," \t","|","|"," ",(0,l.kt)("inlineCode",{parentName:"td"},"false")," logical OR")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"!false")," logical NOT")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Checking if something is true"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"if /* condition */ { "))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"\xa0","\xa0"," only likelihood state has outside effect"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// True statements"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"\xa0","\xa0"," the else part is optional"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"} else {"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"\xa0","\xa0"," we can return from ",(0,l.kt)("inlineCode",{parentName:"td"},"if")," or ",(0,l.kt)("inlineCode",{parentName:"td"},"for")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// False statements"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"}"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Integers need to be converted to reals before comparing"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Real(i) > 5.0"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Looping allows for limited side-effects"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"for i in 1 to 10 { /* statements for i */}"))))),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("p",null,"Example is ",(0,l.kt)("a",{parentName:"p",href:"#is-a-coin-fair"},"Is a coin fair?")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Implementation"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Creating a function"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"function flip(datapoint: Bool, probability: Real) {"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// statements"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// optional return"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"}"))))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A function needs to specify its input parameters and their types."),(0,l.kt)("li",{parentName:"ul"},"A function can have zero input parameters."),(0,l.kt)("li",{parentName:"ul"},"The only effects that a function can have are changing the likelihood, printing things, and returning an output."),(0,l.kt)("li",{parentName:"ul"},"A function may return nothing via ",(0,l.kt)("inlineCode",{parentName:"li"},"return;")," or have no return statement at all."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"return")," statement may appear within a ",(0,l.kt)("inlineCode",{parentName:"li"},"for")," or an ",(0,l.kt)("inlineCode",{parentName:"li"},"if"),".")),(0,l.kt)("h2",{id:"probabilistic-programming"},"Probabilistic programming"),(0,l.kt)("p",null,"Example is ",(0,l.kt)("a",{parentName:"p",href:"#is-a-coin-fair"},"Is a coin fair?")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Feature"),(0,l.kt)("th",{parentName:"tr",align:null},"Implementation"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"The model function specifies our probabilistic model"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"model function coinModel(/* data */) { "))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// specify prior"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// condition the likelihood on data"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"// return posterior"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"}"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Use the ",(0,l.kt)("inlineCode",{parentName:"td"},"assume")," keyword to sample form a prior distribution"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"assume p ~ Beta(a, b);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"assume x ~ Exponential(rate);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"assume y ~ Gamma(shape, scale);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"assume w ~ Gaussian(mean, stdDev);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"assume v ~ Bernoulli(prob);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Use the ",(0,l.kt)("inlineCode",{parentName:"td"},"observe")," keyword to condition the likelihood on observed data"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"observe data ~ Beta(a, b);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"observe data ~ Exponential(a, b);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"observe data ~ Gamma(shape, scale);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"observe data ~ Gaussian(shape, scale);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null}),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"observe data ~ Bernoulli(prob);"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"To manipulate the likelihood directly use ",(0,l.kt)("inlineCode",{parentName:"td"},"weight")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"weight(lik); // lik is not on the logartihmic scale"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"or ",(0,l.kt)("inlineCode",{parentName:"td"},"logWeight")),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"logWeight(lik); // lik is on the logarithmic scale"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"The posterior is the returned value of the model function"),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"return p; // If the likelihood was not manipulated it will be exactly the prior"))))),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("h3",{id:"hello-world"},"Hello world"),(0,l.kt)("p",null,"Let's write our first program.  "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'/*\n * File: hello.tppl\n * Description: Hello, world! Our first program.\n * Compilation:\n *   tpplc models/lang/hello.tppl models/data/standard.mc out.mc && mi compile out.mc\n * Execution: ./out 1 1\n */\n\n/*\n * Model function\n * Parameters: none\n * Returns: nothing\n * Side-effect: prints "Hello, world!"\n */\nmodel function hello() { \n  printLn("Hello, world!")\n}\n')),(0,l.kt)("p",null,"For convenience this program can be found under ",(0,l.kt)("inlineCode",{parentName:"p"},"models/lang/hello.tppl"),".  Since our program has no input, we only need to include ",(0,l.kt)("inlineCode",{parentName:"p"},"models/data/empty.mc"),".  It does not initalize data but does include the standard library."),(0,l.kt)("p",null,"Compile and run:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ tpplc models/lang/blub.tppl models/data/examples.mc out.mc && mi compile out.mc\nmi compile out.mc\n./out 1 1\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"$ ./out 1 1\nHello, world!\n0.\n() 0.\n")),(0,l.kt)("p",null,'The program displays the string "Hello, world!", followed by the normalizing constant and by samples from the described distributions, which are both 0, as the model does nothing but print "Hello, world!".'),(0,l.kt)("h3",{id:"blub"},"Blub"),(0,l.kt)("p",null,"In this blub, we will show how we can pass data to our model and do some operations on it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'/*\n * File: blub.tppl\n * Description: Program to showcase data manipulation.\n * Compilation:\n *   tpplc models/lang/blub.tppl models/data/examples.mc out.mc && mi compile out.mc\n * Execution: ./out 1 1\n */\n\n/*\n * Model function\n * Parameters:\n *   n: Int\n *   pi: Real\n *   trump: Bool\n *   coinflips: Bool[]\n *   text: String\n * Returns: nothing\n * Side-effect: prints things\n */\nmodel function blub(n: Int, pi: Real, trump: Bool, coinflips: Bool[], text: String) {\n  print(text);\n\n  printLn(int2string(n));\n  printLn(real2string(pi)); // will print only a few decimals\n  printLn(bool2string(true));\n\n  printLn(concat("Trump was elected: ", bool2string(trump)));\n\n  let testVec = [1, 2];\n  printLn(int2string(testVec[1]));\n  printLn(int2string(testVec[2]));\n\n  let coinFlipStr = apply(bool2string, coinflips);\n  printLn(concat("The length of the vector is ", int2string(length(coinflips))));\n  let y = join(coinFlipStr); //cannot use concat on more than two argumnets\n  printLn(y);\n\n  printLn(real2string(2.0 + 3.0));\n  printLn(real2string(2.0 * 3.0));\n  printLn(real2string(2.0 / 3.0));\n  printLn(real2string(2.0 - 3.0));\n\n  printLn(bool2string(2.0 < 3.0));\n  printLn(bool2string(2.0 <= 3.0));\n  printLn(bool2string(2.0 == 3.0));\n  printLn(bool2string(2.0 >= 3.0));\n  printLn(bool2string(2.0 > 3.0));\n\n  printLn(bool2string(true && true));\n  printLn(bool2string(true && false));\n  printLn(bool2string(false && true));\n  printLn(bool2string(false && false));\n\n  printLn(bool2string(true || true));\n  printLn(bool2string(true || false));\n  printLn(bool2string(false || true));\n  printLn(bool2string(false || false));\n\n  printLn(bool2string(!false));\n  printLn(bool2string(!true));\n\n  for i in 1 to 10 {\n    if Real(i) > 5.0 {\n      print("\\n"); // cannot use printLn() as a nullary function\n      printLn(join([int2string(i), " is more than ", real2string(5.0)]));\n      return;\n    } else {\n      print(".");\n    }\n  }\n}\n')),(0,l.kt)("p",null,"For convenience this program can be found under ",(0,l.kt)("inlineCode",{parentName:"p"},"models/lang/blub.tppl"),".  The input is predifined in ",(0,l.kt)("inlineCode",{parentName:"p"},"models/data/examples.mc"),", which also includes the standard library."),(0,l.kt)("p",null,"Compile and run:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"$ tpplc models/lang/blub.tppl models/data/examples.mc out.mc && mi compile out.mc\nmi compile out.mc\n$ ./out 1 1\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"blab\n\nblab\n7\n3.14159265359\nTrue\nTrump was elected: False\n1\n2\nThe length of the vector is 20\nTrueTrueTrueFalseTrueFalseFalseTrueTrueFalseFalseFalseTrueFalseTrueFalseFalseTrueFalseFalse\n5.\n6.\n0.666666666667\n-1.\nTrue\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nFalse\nTrue\nFalse\n......\n6 is more than 5.\n0.\n() 0.\n")),(0,l.kt)("p",null,"First time we printed ",(0,l.kt)("inlineCode",{parentName:"p"},"blab")," we have two new lines, because the string itself contains the newline character ",(0,l.kt)("inlineCode",{parentName:"p"},"\\n"),".  Only a few digits of ",(0,l.kt)("inlineCode",{parentName:"p"},"pi")," are printed.  We end with a normalizing constant and an empty sample."),(0,l.kt)("h3",{id:"is-a-coin-fair"},"Is a coin fair?"),(0,l.kt)("p",null,"This is a true ",(0,l.kt)("em",{parentName:"p"},"probabilistic")," program, illustrating sampling from the prior, conditioning the likelihood on observed data, and statistical inference."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"/*\n * File: coin.tppl\n * Description: Simplest meaningful probabilistic program. Evaluates how likely it is that a coin is fair, given data.\n * Compilation:\n *   tpplc models/lang/coin.tppl models/data/examples.mc out.mc && mi compile out.mc\n * Execution: ./out 100 1\n */\n\n/**\n * Conditions the likelihood of the computation \n *   on an observed datapoint to come from a particular Bernoulli experiment \n * Parameters:\n *   datapoint: Real\n *   probability: Real in (0, 1), the probability of True in the Bernoulli experiment\n * Returns: nothing\n * Side-effects: reweighs the computation\n */\nfunction flip(datapoint: Bool, probability: Real) {\n  observe datapoint ~ Bernoulli(probability);\n}\n\n/*\n * Model function\n * Data:\n *   coinflips: Bool[]\n * Prior: \n *   p ~ Beta(2, 2)\n * Posterior:\n *   p | coinflips\n */\nmodel function coinModel(coinflips: Bool[]) {\n  assume p ~ Beta(2.0, 2.0); // prior\n  let n = length(coinflips);\n  for i in 1 to n {\n    flip(coinflips[i], p); // likelihood\n  }\n  return(p); // posterior\n}\n")),(0,l.kt)("p",null,"During compilation we can select which inference method to use.  The supported methods are: "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m is-lw"),": lightweight importance sampling,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m smc-bpf"),": sequential Monte Carlo with bootstrap particle filter,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m smc-apf"),": sequential Monte Carlo with alive particle filter,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m mcmc-lightweight"),": lightweight Markov-chain Monte Carlo,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m mcmc-trace"),": trace Markov-chain Monte Carlo,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m mcmc-naive"),": naive Markov-chain Monte Carlo,")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"-m pmcmc-pimh"),": particle MCMC - particle-independent Metropolis-Hastings."),(0,l.kt)("p",{parentName:"li"},"Default is ",(0,l.kt)("inlineCode",{parentName:"p"},"is-lw"),".  For additional help run ",(0,l.kt)("inlineCode",{parentName:"p"},"tpplc")," without arguments."))))}s.isMDXComponent=!0}}]);